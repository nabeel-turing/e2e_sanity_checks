# This file is automatically generated by the MutationBuilder

def find_files_by_glob(file_name_glob_pattern):
    """
    Search for files in the workspace by glob pattern.

    This function searches for files in the workspace using a glob pattern. It returns a list of
    file paths relative to the workspace root that match the pattern.
    The search is limited to 20 results. This tool is suitable when the filename pattern
    for the desired files is known. Glob patterns are matched starting from the root of the
    workspace folder.

    Examples:
    - '**/*.{js,ts}' to match all js/ts files in the workspace.
    - 'src/**' to match all files under the top-level src folder.
    - '**/foo/**/*.js' to match all js files under any foo folder in the workspace.

    Args:
        file_name_glob_pattern (str): The glob pattern to search for files.

    Returns:
        List[str]: A list of file paths (strings), relative to the workspace root,
                   that match the provided glob pattern. Max 20 results.

    Raises:
        InvalidInputError: If 'file_name_glob_pattern' is not a string or is empty.
        InvalidGlobPatternError: If the provided glob pattern has invalid syntax for fnmatch.
        WorkspaceNotAvailableError: If the user's workspace cannot be accessed or is invalid.
    """
    from copilot.file_system import file_search
    return file_search(glob_pattern=file_name_glob_pattern)


def read_file_segment(target_file_path, first_line_to_read, last_line_to_read):
    """
    Read the contents of a file.

    This function reads a specified range of lines from a file. If the requested
    range is part of a larger file, an outline of the file structure may be
    provided. If the returned content is insufficient, this function can be
    called again to retrieve more content.

    Args:
        target_file_path (str): The path to the file to be read.
        first_line_to_read (int): The 1-based starting line number of the content to retrieve.
        last_line_to_read (int): The 1-based ending line number of the content to retrieve.

    Returns:
        Dict[str, Any]: A dictionary containing a single key "file_details",
                        which in turn holds an object with the content of the
                        requested file segment and related metadata:
            file_details (Dict[str, Any]):
                file_path (str): The path of the file that was read.
                content (str): The content of the requested line range of the file.
                start_line (int): The starting line number (1-based) of the returned content.
                end_line (int): The ending line number (1-based) of the returned content.
                total_lines (int): The total number of lines in the file.
                is_truncated_at_top (bool): True if the returned content does not start from the
                                            beginning of the file due to the requested range.
                is_truncated_at_bottom (bool): True if the returned content does not reach the end
                                               of the file due to the requested range or size limits.
                outline (Optional[List[Dict[str, Any]]]): An optional outline of the file,
                                                          typically provided for larger files or when
                                                          a specific range is not fully covering.
                                                          Each dictionary in the list describes a
                                                          structural element and has the following keys:
                    name (str): Name of the symbol or section (e.g., function name,
                                class name, heading).
                    kind (str): Type of symbol or section (e.g., 'function', 'class',
                                'module', 'section').
                    start_line (int): Start line of the symbol/section in the file.
                    end_line (int): End line of the symbol/section in the file.

    Raises:
        FileNotFoundError: If the specified file path does not exist.
        InvalidLineRangeError: If the specified line range is invalid (e.g., first_line_to_read >
                               last_line_to_read, or lines are out of bounds for the file).
        PermissionDeniedError: If there is no permission to read the specified file.
        InvalidInputError: If input arguments fail validation.
        RuntimeError: If the file entry in the internal database is malformed.
    """
    from copilot.file_system import read_file
    return read_file(
        file_path=target_file_path,
        start_line=first_line_to_read,
        end_line=last_line_to_read
    )


def list_directory_contents(directory_path_to_list):
    """
    List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file.

    This function lists the contents of a specified directory. For each entry
    found, which represents a child item, its name is provided. A trailing
    slash ('/') in an entry's name indicates that the entry is a folder;
    otherwise, the entry is considered a file.

    Args:
        directory_path_to_list (str): The path to the directory whose contents are to be listed.

    Returns:
        List[Dict[str, Any]]: A list of items found in the specified directory. Each item is a
            dictionary detailing a file or directory entry and includes the following
            keys:
            name (str): The name of the file or subdirectory. Directory names end
                with a '/' suffix.
            type (str): The type of the entry, either 'file' or 'directory'.
            path (str): The full path to the file or directory entry.

    Raises:
        DirectoryNotFoundError: If the specified directory directory_path_to_list does not exist or is not a directory.
        PermissionDeniedError: If there is no permission to list the contents of the directory.
        InvalidInputError: If input arguments fail validation.
    """
    from copilot.file_system import list_dir
    return list_dir(path=directory_path_to_list)


def apply_code_changes_to_file(file_to_be_modified, code_modification_instructions, change_summary_explanation):
    """
    Insert new code into an existing file in the workspace.

    Inserts new code into an existing file in the workspace. This function is used
    once per file that needs modification, even if there are multiple changes for
    that file. The `explanation` property should be generated first. The system
    intelligently applies edits based on minimal hints. It is important to avoid
    repeating existing code in the `edit_instructions`; instead, comments
    (e.g., `// ...existing code...`) represent regions of unchanged code,
    aiming for conciseness. For example:
    // ...existing code...
    { changed code }
    // ...existing code...
    { changed code }
    // ...existing code...

    An example of how to format an edit to an existing `Person` class:
    class Person {
        // ...existing code...
        age: number;
        // ...existing code...
        getAge() {
            return this.age;
        }
    }

    Args:
        file_to_be_modified (str): The path of the file within the workspace that needs to be modified.
        code_modification_instructions (str): The content representing the changes to be applied to the file. Follow the concise diff-like format: use comments (e.g., '// ...existing code...') to represent regions of unchanged code and provide only the new or modified code blocks.
        change_summary_explanation (str): A natural language explanation of the changes being made in this edit. This should be generated first.

    Returns:
        Dict[str, Any]: A dictionary containing the result, with keys:
            file_path (str): The absolute path of the file that was targeted.
            status (str): Status of the edit operation (e.g., 'success', 'failed_to_apply', 'file_not_found').
            message (Optional[str]): Details of the operation or error.

    Raises:
        EditConflictError: If the target path is a directory, or content is an uneditable placeholder.
        PermissionDeniedError: If the file is marked read-only.
        InvalidEditFormatError: Conditions for this are less direct with LLM-based rewrite.
                                It might be raised if, hypothetically, an LLM output format was strictly defined
                                and not met in a way that other errors don't cover. Currently, LLM content
                                issues are typically mapped to 'failed_to_apply' or are part of a 'success'
                                if the content is merely low quality but technically applied.
    """
    from copilot.file_system import insert_edit_into_file
    return insert_edit_into_file(
        file_path=file_to_be_modified,
        edit_instructions=code_modification_instructions,
        explanation=change_summary_explanation
    )
