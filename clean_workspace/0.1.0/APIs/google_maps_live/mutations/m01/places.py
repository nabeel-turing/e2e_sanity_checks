# This file is automatically generated by the MutationBuilder

def search_for_locations(
    search_phrases,
    search_area_preference=None,
    filter_by_open_status=None,
    minimum_star_rating=None,
    desired_price_ranges=None,
    result_ranking_method=None,
    unsupported_search_during_travel=None,
    unsupported_check_search_history=None,
    unsupported_check_saved_places=None,
    unsupported_enable_immersive_display=None
):
    """
    Query and locate places or geographical entities.

    This function searches for businesses, stores, restaurants, parks, attractions, cities, 
    countries, and other places of interest. It can handle multiple queries and returns 
    structured place data. All inputs are validated using Pydantic models.

    Note: This API cannot handle generic Google search queries or image search queries.

    Args:
        search_phrases (List[str]): List of search queries describing desired characteristics of places.
                          Must contain at least one query. Examples: ["coffee shops", "parks near me"]
        search_area_preference (Optional[Union[str, Dict[str, Any]]]): Location bias for search results. 
                                                             Can be a place name string, coordinate dict 
                                                             {"latitude": float, "longitude": float}, or string names of environment variables:
                                                             - "MY_HOME": User's home location from environment
                                                             - "MY_LOCATION": User's current location from environment
                                                             - "MY_WORK": User's work location from environment
        filter_by_open_status (Optional[bool]): If True, filters results to show only places currently open.
        minimum_star_rating (Optional[float]): Minimum rating filter (1.0 to 5.0). Returns only places with 
                                     this rating or higher.
        desired_price_ranges (Optional[List[str]]): Price level filters. Supported values: "inexpensive", 
                                           "moderate", "expensive", "very_expensive".
        result_ranking_method (Optional[str]): Ranking preference for results. Supported values: "default", "distance".
        unsupported_search_during_travel (Optional[Dict[str, Any]]): Parameters for searching along a route (currently unsupported).
        unsupported_check_search_history (Optional[bool]): Whether to search in history (currently unsupported).
        unsupported_check_saved_places (Optional[bool]): Whether to search saved places (currently unsupported).
        unsupported_enable_immersive_display (Optional[bool]): Whether to include immersive views (currently unsupported).

    Returns:
        Dict[str, Any]: Summary of places containing:
            - map_url (str): URL to view places on Google Maps
            - places (List[Dict]): List of places with details including:
                - name (str): Place name
                - description (str): Place description
                - address (str): Full address
                - phone (str): Phone number
                - website (str): Website URL
                - rating (float): Average rating (1.0-5.0)
                - price_level (str): Price level indicator
                - place_id (str): Unique place identifier
            - detours (List[Dict]): List of detour information (if applicable)
            - query (str): The search query used

    Raises:
        ValueError: If search_phrases list is empty
        ValueError: If minimum_star_rating is not between 1.0 and 5.0
        ValueError: If invalid desired_price_ranges are provided
        ValueError: If invalid result_ranking_method is provided
        ValueError: If input validation fails
        ParseError: If JSON parsing from API response fails
        NotImplementedError: If API response cannot be parsed as valid JSON
        ValidationError: If response data doesn't match expected schema
        UndefinedLocationError: If UserLocation environment variable is not set
    """
    from google_maps_live.places import query_places
    return query_places(
        query=search_phrases,
        location_bias=search_area_preference,
        only_open_now=filter_by_open_status,
        min_rating=minimum_star_rating,
        price_levels=desired_price_ranges,
        rank_preference=result_ranking_method,
        search_along_route=unsupported_search_during_travel,
        in_history=unsupported_check_search_history,
        is_saved=unsupported_check_saved_places,
        immersive_view=unsupported_enable_immersive_display
    )


def get_information_for_places(location_identifiers, contextual_filter_query=None):
    """
    Fetch detailed information about places using their IDs.

    This function retrieves enriched place details for the specified place IDs.
    All inputs are validated using Pydantic models.

    Args:
        location_identifiers (List[str]): List of place ids.
        contextual_filter_query (Optional[str]): Optional query which query can be used for semantic filtering 
                              of place data, e.g. finding relevant reviews.

    Returns:
        List[Dict[str, Any]]: List of places with detailed information.

    Raises:
        ValueError: If location_identifiers list is empty
        ParseError: If JSON parsing from API response fails
        NotImplementedError: If API response cannot be parsed as valid JSON
        ValidationError: If response data doesn't match expected schema
    """
    from google_maps_live.places import lookup_place_details
    return lookup_place_details(place_ids=location_identifiers, query=contextual_filter_query)


def get_insights_on_locations(place_identifier_list, natural_language_inquiry):
    """
    Analyze places using natural language queries.

    This function provides intelligent analysis of places based on natural language questions.
    All inputs are validated using Pydantic models.

    Args:
        place_identifier_list (List[str]): List of place ids.
        natural_language_inquiry (str): Question in natural language form.

    Returns:
        Dict[str, Any]: Analyze result containing:
            - map_answer (str): Analysis result in natural language form
            - web_answers (List[Dict]): List of web answers
            - place_images_passthrough (str): Image data (hidden from model)
            - image_grid_passthrough (str): Image grid data (hidden from model)

    Raises:
        ValueError: If place_identifier_list list is empty
        ValueError: If natural_language_inquiry is empty
        ParseError: If JSON parsing from API response fails
        NotImplementedError: If API response cannot be parsed as valid JSON
        ValidationError: If response data doesn't match expected schema
    """
    from google_maps_live.places import analyze_places
    return analyze_places(place_ids=place_identifier_list, question=natural_language_inquiry)


def display_locations_on_map(points_of_interest_to_show=None):
    """
    Display places on a map.

    This function generates a map containing pins for the specified places.
    All inputs are validated using Pydantic models.

    Args:
        points_of_interest_to_show (Optional[List[str]]): List of place ids or place names to be shown on the map. 
                                     If place ids are provided, they should always have a prefix 'place_id://'.

    Returns:
        Dict[str, Any]: Show map result containing:
            - content_id (str): Unique identifier for the map content
            - place_marker_passthrough (str): Place marker data (hidden from model)
            - map_title (str): Title for the map (hidden from model)

    Raises:
        ValueError: If points_of_interest_to_show list is empty when provided
        ParseError: If JSON parsing from API response fails
        NotImplementedError: If API response cannot be parsed as valid JSON
        ValidationError: If response data doesn't match expected schema
    """
    from google_maps_live.places import show_on_map
    return show_on_map(places=points_of_interest_to_show)
