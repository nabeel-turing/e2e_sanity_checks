# This file is automatically generated by the MutationBuilder

def get_database_tables_by_schema(database_project_id, target_schema_names=None):
    """
    Lists all tables in one or more schemas.

    This function lists all tables found within one or more specified schemas for a given project.
    If the `schemas` parameter is not provided, it defaults to listing tables from all available schemas
    associated with the `project_id`.

    Args:
        database_project_id (str): The identifier of the project.
        target_schema_names (Optional[List[str]]): List of schemas to include. Defaults to all schemas if None.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary (representing a table object)
        details a single table and includes the following keys:
            name (str): The name of the table.
            schema (str): The schema the table belongs to.
            comment (Optional[str]): The comment associated with the table, if any.
            columns (List[Dict[str, Any]]): A list of column dictionaries detailing the table's columns.
                Each column dictionary contains:
                    name (str): The name of the column.
                    data_type (str): The data type of the column.
                    is_nullable (bool): Indicates if the column can contain NULL values.
                    default_value (Optional[str]): The default value of the column, if any.
            primary_keys (List[Dict[str, Any]]): A list of dictionaries representing primary key columns.
                Each primary key dictionary contains:
                    name (str): The name of the primary key column.
            relationships (List[Dict[str, Any]]): A list of dictionaries detailing foreign key relationships.
                Each relationship dictionary contains:
                    constraint_name (str): The name of the foreign key constraint.
                    source_schema (str): The schema of the table containing the foreign key.
                    source_table_name (str): The name of the table containing the foreign key.
                    source_column_name (str): The name of the column in the source table that is part of the foreign key.
                    target_table_schema (str): The schema of the table referenced by the foreign key.
                    target_table_name (str): The name of the table referenced by the foreign key.
                    target_column_name (str): The name of the column in the target table referenced by the foreign key.

    Raises:
        NotFoundError: If the database_project_id does not exist.
        ValidationError: If input arguments fail validation.
    """
    from supabase.database import list_tables
    return list_tables(project_id=database_project_id, schemas=target_schema_names)


def fetch_installed_database_extensions(project_id_for_extensions):
    """
    Lists all extensions in the database.

    This function lists all extensions in the database associated with the specified project.

    Args:
        project_id_for_extensions (str): The identifier of the project.

    Returns:
        List[Dict[str, Any]]: A list of database extensions. Each dictionary in the list
            represents an extension and contains the following fields:
            name (str): The name of the extension.
            schema (str): The schema where the extension is installed.
            version (str): The version of the extension.
            description (str): A description of the extension.

    Raises:
        NotFoundError: If the project_id_for_extensions does not exist.
        ValidationError: If input arguments fail validation.
    """
    from supabase.database import list_extensions
    return list_extensions(project_id=project_id_for_extensions)


def get_all_database_migrations(project_ref_for_migrations):
    """
    Lists all migrations in the database.

    This function lists all migrations in the database associated with the provided project_id.

    Args:
        project_ref_for_migrations (str): The identifier of the project.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary represents a database migration and includes the following keys:
            version (str): The version identifier of the migration (often a timestamp).
            name (str): The descriptive name of the migration.
            status (str): The status of the migration (e.g., 'applied', 'pending').
            applied_at (Optional[str]): ISO 8601 timestamp of when the migration was applied, if applicable.

    Raises:
        NotFoundError: If the project_ref_for_migrations does not exist.
        PydanticValidationError: If input arguments fail validation.
    """
    from supabase.database import list_migrations
    return list_migrations(project_id=project_ref_for_migrations)


def execute_schema_migration(target_project_ref, migration_identifier_name, migration_sql_script):
    """
    Applies a migration to the database.

    Applies a migration to the database. Use this when executing DDL operations.
    Do not hardcode references to generated IDs in data migrations.

    Args:
        target_project_ref (str): The ID of the project.
        migration_identifier_name (str): The name of the migration in snake_case.
        migration_sql_script (str): The SQL query to apply.

    Returns:
        Dict[str, Any]: Result of the migration application, detailing its outcome.
                        Contains the following fields:
            version (str): The version identifier of the applied migration,
                           used for tracking (often derived from name or timestamp).
            name (str): The name of the applied migration.
            status (str): Status of the migration (e.g., 'APPLIED_SUCCESSFULLY',
                          'FAILED').
            message (Optional[str]): Any relevant messages from the migration
                                     process, such as error details if it failed.

    Raises:
        NotFoundError: If the target_project_ref does not exist.
        ValidationError: If the migration migration_identifier_name or migration_sql_script is invalid or missing.
        MigrationError: If the migration migration_sql_script fails to apply (e.g., SQL syntax
                        error, conflicts with existing schema, transaction rollback).
    """
    from supabase.database import apply_migration
    return apply_migration(
        project_id=target_project_ref,
        name=migration_identifier_name,
        query=migration_sql_script
    )


def run_raw_sql_query(project_db_identifier, sql_command_string):
    """
    Executes raw SQL in the Postgres database. Use `apply_migration` instead for DDL operations.

    This function simulates PostgreSQL query execution for the Supabase API simulation.
    All operations are performed in-memory with no persistence between sessions.

    Supported SQL Operations:
    - SELECT queries with WHERE, JOIN, GROUP BY, HAVING, ORDER BY, LIMIT
    - INSERT statements (single and multiple rows)
    - UPDATE statements with WHERE conditions
    - DELETE statements with WHERE conditions
    - Basic DDL: CREATE TABLE, ALTER TABLE, DROP TABLE
    - Transaction commands: BEGIN, COMMIT, ROLLBACK
    - Multi-schema support (e.g., public.users, analytics.products)

    Supported Data Types:
    - Text types: TEXT, VARCHAR, CHAR
    - Numeric types: INTEGER, BIGINT, SMALLINT, DECIMAL, NUMERIC, REAL, DOUBLE
    - Boolean: BOOLEAN
    - Date/Time: DATE, TIME, TIMESTAMP, TIMESTAMP WITH TIME ZONE
    - UUID (stored as VARCHAR internally)
    - JSON/JSONB (stored as JSON)
    - SERIAL/BIGSERIAL types (converted to INTEGER/BIGINT, auto-increment not supported)

    PostgreSQL Compatibility Notes:
    - SERIAL/BIGSERIAL columns are converted to INTEGER/BIGINT (manual ID management required)
    - PostgreSQL functions like now() and uuid_generate_v4() are automatically converted
    - Foreign key constraints across different schemas are not supported
    - Type OIDs in responses are approximated based on common PostgreSQL types

    Limitations of this simulation:
    - PostgreSQL-specific functions are limited (e.g., array functions, full-text search)
    - Advanced features like CTEs and window functions have limited support
    - Stored procedures, functions, and triggers are not supported
    - PostgreSQL extensions (postgis, pg_trgm, etc.) are not available
    - Transaction isolation levels are not enforced
    - Constraints are partially supported (PRIMARY KEY works, CHECK constraints work, but foreign keys have limitations)
    - No support for COPY, VACUUM, ANALYZE, or other maintenance commands
    - Limited support for advanced index types (only basic indexes work)
    - Sequences and auto-increment functionality not available
    - User-defined types and domains are not supported

    Args:
        project_db_identifier (str): The project ID.
        sql_command_string (str): The SQL query to execute.

    Returns:
        Dict[str, Any]: The result of the SQL query execution. The structure of this dictionary varies based on the type of SQL query executed.

            For SELECT queries, this dictionary typically contains:
            `rows`: List[Dict[str, Any]] - A list of dictionaries, where each dictionary represents a data row. In each row dictionary, keys are column names (str) and values are the corresponding cell data (Any).
            `columns`: List[Dict[str, Any]] - A list of dictionaries, each describing a column in the result set. Each column dictionary has the following keys:
                `name`: str - The name of the column.
                `type_oid`: int - The PostgreSQL Object Identifier (OID) for the column's data type.
            `row_count`: int - The number of rows returned by the SELECT query.

            For Data Manipulation Language (DML) statements (e.g., INSERT, UPDATE, DELETE), this dictionary typically contains:
            `row_count`: int - The number of rows affected by the DML statement.
            `status_message`: str - A status message from the database indicating the outcome of the DML operation (e.g., 'INSERT 0 1', 'UPDATE 5').

    Raises:
        NotFoundError: If the project_db_identifier does not exist.
        InvalidInputError: If the sql_command_string is missing or malformed.
        DatabaseConnectionError: If there's an issue connecting to the project's database.
        SQLError: If the SQL sql_command_string is invalid, encounters a runtime error during execution, or violates database constraints.
    """
    from supabase.database import execute_sql
    return execute_sql(project_id=project_db_identifier, query=sql_command_string)
