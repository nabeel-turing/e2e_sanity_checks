# This file is automatically generated by the MutationBuilder

def get_directory_listing(folder_to_inspect, operation_reason=None):
    """
    Lists the immediate contents of a directory within the configured workspace.

    Resolves the provided path relative to the workspace root and queries the
    internal file system representation to find direct children (files and
    subdirectories).

    This function is primarily intended for exploring the workspace structure
    and discovering file/directory names at a specific location. It often serves
    as a preliminary step before using more targeted tools like `read_file`,
    `grep_search`, or `codebase_search` on specific items found in the listing.

    Args:
        folder_to_inspect (str): The path of the directory to list,
            relative to the workspace root. An empty string or '.' refers
            to the workspace root itself. Leading slashes are stripped.
        operation_reason (Optional[str], optional): A description of the reason for
            this operation, potentially used for logging or auditing. Defaults to None.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
        represents a file or subdirectory found within the specified path.
        Each item dictionary contains:
            - 'path' (str): The full, normalized absolute path of the item.
            - 'name' (str): The base name of the item (file or directory name).
            - 'is_directory' (bool): True if the item is a directory, False otherwise.
            - 'size_bytes' (int): The size of the item in bytes. For directories,
              this is typically 0 in this representation.
            - 'last_modified' (str): An ISO 8601 timestamp string indicating
              the last modification time of the item.
        Returns an empty list if the directory exists and is valid but contains no items.

    Raises:
        ValueError: If 'workspace_root' is not configured or the resolved path
            is outside the permitted workspace boundaries.
        FileNotFoundError: If the target directory path does not exist.
        NotADirectoryError: If the path exists but is not a directory.
        InvalidInputError: If input arguments have invalid types.
    """
    from cursor.cursorAPI import list_dir
    return list_dir(relative_workspace_path=folder_to_inspect, explanation=operation_reason)


def remove_file_from_workspace(file_to_remove, deletion_justification=None):
    """
    Deletes a specified file from the application's managed file system.

    Resolves the provided path relative to the workspace root and attempts to
    remove the corresponding file entry from the application's internal file
    system representation.

    This operation raises appropriate errors for failure scenarios: if the file does
    not exist, if the target path refers to a directory, or if path resolution fails.
    Only successful deletions return a success dictionary.

    Args:
        file_to_remove (str): The path of the file to be deleted, relative to the
            workspace root. Leading slashes are stripped to ensure the path is
            treated as relative.
        deletion_justification (Optional[str], optional): A description of the reason for
            this deletion. Not used in the return value but may be utilized for
            logging or auditing. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary indicating the outcome of the operation.
        It contains:
            - 'success' (bool): True if the file was successfully deleted or
              if the file did not exist (idempotent success). False if the
              target was a directory or another error prevented deletion.
            - 'message' (str): A message describing the outcome.
            - 'path_processed' (Optional[str]): The absolute path that was
              processed for deletion. None if path resolution failed early.

    Raises:
        ValueError: If 'workspace_root' is not configured, or if the resolved
            path for `file_to_remove` would point outside the configured workspace.
        InvalidInputError: If the target file path is empty, invalid, or arguments have invalid types.
        IsADirectoryError: If the target path refers to a directory.
        RuntimeError: For unexpected errors during the deletion process.
    """
    from cursor.cursorAPI import delete_file
    return delete_file(target_file=file_to_remove, explanation=deletion_justification)


def find_file_by_fuzzy_path(file_path_query, search_purpose_description):
    """
    Performs a fuzzy search for files based on matching a query against file paths.

    Searches through the file paths within the application's internal file system
    representation using fuzzy matching algorithms. This is useful when part of 
    a file path or name is known, but the exact location is not. It returns a 
    ranked list of file paths (excluding directories) based on similarity to the query.

    Results are capped at a maximum of 10 matches; more specific queries will
    yield narrower results.

    Args:
        file_path_query (str): The string to search for within file paths. Fuzzy matching
                     attempts to account for typos and partial matches.
        search_purpose_description (str): A required sentence explaining the reason for this search,
                           typically for logging or auditing purposes.

    Returns:
        List[str]: A list of absolute, normalized file paths that best match the
                   query, sorted by relevance (highest score first). The list
                   is capped at 10 results. Returns an empty list if no suitable
                   matches are found, the query is empty, or no files exist.

    Raises:
        ImportError: If the required 'thefuzz' library is not installed.
                     (Handled implicitly by the top-level import).
        InvalidInputError: If input arguments have invalid types.
    """
    from cursor.cursorAPI import file_search
    return file_search(query=file_path_query, explanation=search_purpose_description)


def search_contents_with_regex(
    regex_pattern,
    scan_justification=None,
    match_case=True,
    inclusion_glob_filter=None,
    exclusion_glob_filter=None
):
    """
    Performs a text search using a regular expression across applicable files.

    Scans the content of files within the application's internal file system
    representation, optionally filtering by include/exclude glob patterns.
    It searches each line using the provided regex query, respecting case
    sensitivity. This function is optimized for finding exact text matches or
    specific patterns and is generally more precise than semantic search for
    locating known symbols, function names, or literal strings.

    The query must be a valid regex pattern; ensure special characters intended
    for literal matching are properly escaped (e.g., '\.' to match a period).
    Found matches include file path, line number, and content, capped at the
    first 50 matches found across all searched files.

    Args:
        regex_pattern (str): The regular expression pattern to search for. Callers should
                     ensure the pattern is valid and escape special characters if
                     literal matching is intended (e.g., '\.' for a literal dot).
        scan_justification (Optional[str], optional): A description of the reason for
            this search, primarily for logging or auditing. Defaults to None.
        match_case (bool, optional): Determines if the regex search respects
            character case (True) or ignores case (False). Defaults to True.
        inclusion_glob_filter (Optional[str], optional): A glob pattern (e.g., '*.py', 'src/**')
            to filter which file paths are included in the search. If omitted,
            all files passing the exclude filter are considered. Defaults to None.
        exclusion_glob_filter (Optional[str], optional): A glob pattern to filter
            which file paths are excluded from the search. Exclusions override
            inclusions. Defaults to None.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries for each regex match found.
        Each dictionary contains:
            - 'file_path' (str): Absolute path of the file with the match.
            - 'line_number' (int): 1-based line number of the match.
            - 'line_content' (str): The text content of the matching line
                                    (trailing newline character removed).
        The list is capped at the first 50 matches found across all searched files.
        Returns an empty list if the query is empty, invalid, or yields no matches.

    Raises:
        ValueError: If the provided regex pattern is invalid.
        InvalidInputError: If input arguments have invalid types.
    """
    from cursor.cursorAPI import grep_search
    return grep_search(
        query=regex_pattern,
        explanation=scan_justification,
        case_sensitive=match_case,
        include_pattern=inclusion_glob_filter,
        exclude_pattern=exclusion_glob_filter
    )


def apply_structured_code_change(file_path_to_edit, structured_diff_content, change_summary_instruction):
    """
    Proposes an edit to an existing file or creates a new file.

    This function generates a structured edit that is read and applied by a less intelligent model.
    The edit specifies changes clearly while minimizing the amount of unchanged code. Changes are
    specified in sequence, with the special comment `// ... existing code ...` representing
    unchanged code between edited lines.

    For example:
    ```
    // ... existing code ...
    FIRST_EDIT
    // ... existing code ...
    SECOND_EDIT
    // ... existing code ...
    THIRD_EDIT
    // ... existing code ...
    ```

    The edit repeats as few lines of the original file as possible, but contains sufficient
    context of unchanged lines to resolve ambiguity. Omitting the `// ... existing code ...`
    comment for pre-existing code may cause the model to inadvertently delete those lines.
    Creating a new file involves specifying the entire file content in the `code_edit` field.

    Args:
        file_path_to_edit (str): The target file to modify. This argument is always specified first. Its path can be relative to the workspace or absolute, and an absolute path is preserved.
        structured_diff_content (str): Contains only the precise lines of code to edit. It never contains unchanged code; instead, it represents unchanged code using a language-appropriate comment like `// ... existing code ...`.
        change_summary_instruction (str): A single sentence instruction describing the change being made in the sketched edit. It assists the less intelligent model in applying the edit by providing a concise summary that avoids repeating information from previous messages and disambiguates any uncertainty in the edit.

    Returns:
        Dict[str, Any]: A dictionary indicating the outcome. Contains:
            - 'success' (bool): True if the file was successfully edited or created.
            - 'message' (str): A message describing the outcome.
            - 'file_path' (str): The absolute, normalized path of the file processed.

    Raises:
        ValueError: If path resolution fails, path is outside workspace, or code edit fails due to context matching issues.
        IsADirectoryError: If the target path is a directory.
        FileNotFoundError: If a parent directory does not exist for a new file.
        InvalidInputError: If the target file path for creation is invalid or arguments have invalid types.
        RuntimeError: For any other unexpected errors.
    """
    from cursor.cursorAPI import edit_file
    return edit_file(
        target_file=file_path_to_edit,
        code_edit=structured_diff_content,
        instructions=change_summary_instruction
    )


def find_code_by_semantic_query(natural_language_description, search_rationale=None, search_scope_filters=None):
    """
    Finds code snippets semantically relevant to a natural language query,
    filtered by target directories if specified.

    This function searches the codebase for code segments that match the meaning
    and intent of the user's query, rather than just exact keywords. It also
    searches git repository metadata for additional context related to the query,
    providing both code snippets and relevant git information when available.
    Results include commit hash information for integration with git history tools.

    Guidelines for use:
    - To find code related to a specific task, feature description, or conceptual question 
      (e.g., "find how user authentication is handled", "show me data validation logic", 
      "where are API request parsers defined?").
    - When the exact file names or function/class names are unknown.
    - To get an understanding of how certain concepts are implemented across various 
      parts of the codebase.

    Args:
        natural_language_description (str): The natural language search query describing the functionality,
            concept, or implementation to find. Should be descriptive rather than
            using exact function or variable names.
        search_rationale (Optional[str]): Optional description of the search purpose
            for logging and debugging. Used to track search patterns. Defaults to None.
        search_scope_filters (Optional[List[str]]): Optional list of glob patterns to
            restrict search scope to specific directories or file patterns.
            Examples: ['src/**', 'lib/*.py', 'components/*']. Defaults to None
            for full codebase search.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries representing matched code snippets
        and git metadata, ordered by relevance. Each dictionary contains:
            file_path (str): Absolute path to the file containing the code snippet
            snippet_bounds (dict): Dictionary with 'start' and 'end' keys indicating 
                line numbers (1-indexed) of the code segment
            snippet_content (str): The actual code content of the matched segment
            commit_hash (str): The git commit hash associated with the code lines
            relevance_score (float): Semantic similarity score between 0.0 and 1.0
            is_git_metadata (bool): Present and True for git metadata entries 
                (commit messages, PR references) rather than code content
            git_context (str): For git metadata entries, contains the commit message,
                branch name, or PR information that matched the query

    Raises:
        ValueError: If any of the following conditions are met:
            - The `natural_language_description` parameter is not a non-empty string.
            - The `search_scope_filters` parameter is provided but is not a list of non-empty strings.
            - The workspace root is not configured in the application settings.
            - The resolved workspace root is invalid.
    """
    from cursor.cursorAPI import codebase_search
    return codebase_search(
        query=natural_language_description,
        explanation=search_rationale,
        target_directories=search_scope_filters
    )


def retrieve_file_segment_with_summary(
    file_path_to_read,
    first_line_to_read,
    final_line_to_read,
    read_full_file=False,
    read_operation_purpose=None
):
    """
    Read the contents of a file from the application's managed file system.

    This function reads a specified range of lines from a file within the workspace and provides the summary of the
    file content outside of that specified range of lines. It can read a specific range of lines or the entire file based on the
    should_read_entire_file parameter. The function handles path resolution, validates the file exists, and ensures the
    requested line range is valid. If the requested `start_line_one_indexed` is out of bounds (greater than the total
    number of lines), the function will instead read up to the last 250 lines of the file.

    Guidelines for use:
        - You can view up to 250 lines at a time.
        - After each read, check if you have enough context to proceed with your task.
        - Note any lines that were not shown, and if you suspect important information is outside the viewed range,
          read those lines as well.
        - When unsure, read additional lines to ensure you have the complete context.
        - Avoid reading the entire file unless absolutely necessary as this can be slow and inefficient for large files.

    Args:
        file_path_to_read (str): The path of the file to read. Can be relative to the workspace root or absolute.
            If absolute, it will be used as is. If relative, it will be joined with workspace root.
        read_full_file (bool): Whether to read the entire file. If True,
            start_line_one_indexed and end_line_one_indexed_inclusive are ignored.
        first_line_to_read (int): The one-indexed line number to start reading from (inclusive).
            Must be >= 1 and <= end_line_one_indexed_inclusive.
        final_line_to_read (int): The one-indexed line number to end reading at (inclusive).
            Must be >= start_line_one_indexed and <= total lines in file.
        read_operation_purpose (Optional[str], optional): A description of why this operation is being performed.
            Not used in the return value but may be utilized for logging or auditing.
            Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - 'success' (bool): True if the read-file was successful.
            - 'start_line' (int): The line number of the start line.
            - 'end_line' (int): The line number of the last line returned in 'content'. This may be different from the requested end line if the range was adjusted.
            - 'content' (List[str]): The requested lines from the file, up to a maximum of 250 lines. If the requested range exceeds 250 lines, only the first 250 lines of the range will be returned.
            - 'total_lines' (int): The total number of lines in the file.
            - 'path_processed' (str): The absolute path that was processed.
            - 'summary_of_truncated_content' (Optional[str]): A descriptive summary of the content before the returned 'start_line' and after the returned 'end_line' (which may be less than the requested end line if truncation occurred).
            - 'message' (str): A descriptive message detailing the outcome of the read operation. It will specify if the requested range was adjusted due to file size, being out of bounds, or exceeding the line limit. This field will always be populated.

    Raises:
        ValueError:
            - If the workspace root is not configured in the application settings.
            - If the resolved file path is outside the permitted workspace boundaries.
            - If the start line is greater than the end line.
            - If the start line is less than 1.
            - If the start or end line exceeds the total number of lines in the file (when not reading the entire file).
        InvalidInputError: If the target file path is empty or invalid.
        FileNotFoundError: If the target file does not exist.
        IsADirectoryError: If the target path is a directory.
    """
    from cursor.cursorAPI import read_file
    return read_file(
        target_file=file_path_to_read,
        start_line_one_indexed=first_line_to_read,
        end_line_one_indexed_inclusive=final_line_to_read,
        should_read_entire_file=read_full_file,
        explanation=read_operation_purpose
    )


def retry_failed_edit(file_with_failed_edit):
    """
    Re-applies the last attempted edit for a file using enhanced processing.

    This function retrieves the instructions and code edit details from the
    previously recorded edit operation for the specified `target_file`. It then
    invokes an LLM, providing the original instructions, the prior edit attempt,
    and the file's current content. The LLM generates the intended complete,
    final content of the file. This new content directly replaces the existing
    content in the application's internal file representation.

    Use this function only if a preceding `edit_file` operation produced an
    unexpected or incorrect result.

    Args:
        file_with_failed_edit (str): The path of the file to re-apply the last edit to
                           (relative to CWD or absolute within the workspace).

    Returns:
        Dict[str, Any]: A dictionary indicating the outcome:
            - 'success' (bool): True if the re-application was successful.
            - 'message' (str): A message describing the outcome.
            - 'file_path' (str): The absolute path of the file processed.

    Raises:
        ValueError: If the workspace root is not configured or the file path is invalid.
        FileNotFoundError: If the target file is not found.
        IsADirectoryError: If the target path is a directory.
        LastEditNotFoundError: If no relevant previous edit is found for the file.
        InvalidInputError: If original instructions from the last edit are missing.
        LLMGenerationError: If the LLM fails to generate content for the re-application.
        RuntimeError: For any other unexpected errors.
    """
    from cursor.cursorAPI import reapply
    return reapply(target_file=file_with_failed_edit)


def execute_shell_command(
    command_string_to_execute,
    command_justification,
    run_as_background_process=False
):
    """
    Executes the provided terminal command in the current workspace context.

    Use this function to run shell commands. You need to provide the exact
    command string to be executed. Note that commands like 'cd', 'pwd', and
    environment commands ('export', 'unset', 'env') are handled internally;
    other commands are executed externally and may modify the workspace files.

    IMPORTANT: For any command that expects user interaction or uses a pager
    (like git diff, git log, less, more, etc.), you MUST append
    ' | cat' to the command string yourself before passing it to this function.
    Failure to do so will cause the command to hang or fail.

    For commands that are intended to run for a long time or indefinitely
    (e.g., starting a server, running a watch process), set the
    `is_background` parameter to True.

    Args:
        command_string_to_execute (str): The exact terminal command string to execute. Remember
                       to append ' | cat' for interactive/pager commands.
        command_justification (str): A brief justification for running this command, which
                           may be shown to the user or used for logging.
        run_as_background_process (bool, optional): Set to True to run the command as a
            background process (e.g., for servers or watchers). Defaults to False,
            running the command in the foreground and waiting for completion.

    Returns:
        Dict[str, Any]: A dictionary describing the outcome:
            - 'success' (bool): Indicates if the command launched successfully
                                (background) or completed with exit code 0
                                (foreground).
            - 'message' (str): A status message about the execution.
            - 'stdout' (str): Captured standard output (foreground only).
            - 'stderr' (str): Captured standard error (foreground only).
            - 'returncode' (Optional[int]): The command's exit code
                                           (foreground only).
            - 'pid' (Optional[int]): The process ID if run in the background.

    Raises:
        ValueError: If workspace_root is not configured or the command_string_to_execute string is empty/invalid.
        CommandExecutionError: If a command_string_to_execute fails to launch, `cd` fails, or a foreground command_string_to_execute returns a non-zero exit code.
    """
    from cursor.cursorAPI import run_terminal_cmd
    return run_terminal_cmd(
        command=command_string_to_execute,
        explanation=command_justification,
        is_background=run_as_background_process
    )


def retrieve_commit_or_pr_changes(pr_number_or_commit_id):
    """
    Looks up a pull request by number or a commit by commit hash and returns the diff.

    This function integrates with the git repository to fetch real diffs and commit information.
    It can resolve PR numbers by finding commits that reference them in commit messages, or 
    directly show commit diffs. The function returns comprehensive information including the
    formatted diff, author details, and file changes.

    Pull requests and commit hashes related to files can be found via the
    'read_file' and 'codebase_search' tools. You should generally use this
    tool following a 'codebase_search' toolcall rather than making a new
    'codebase_search' or 'read_file' tool call.

    Args:
        pr_number_or_commit_id (str): The pull request number (without '#' prefix) or 
            commit hash (full or abbreviated). For PR numbers, the function searches 
            for commits referencing that PR in their messages.

    Returns:
        Dict[str, Any]: A dictionary containing comprehensive commit and diff information:
            type (str): Either 'pull_request' or 'commit' indicating the source type
            identifier (str): The original input value (PR number or commit hash)
            commit_hash (str): The resolved commit SHA hash used for the diff
            author (str): The commit author's name and email as recorded in git
            message (str): The complete commit message including subject and body
            diff (str): The professionally formatted unified diff with visual enhancements
            files_changed (list): List of file paths that were modified in this commit
            stats (str): Statistical summary of changes (insertions/deletions)

    Raises:
        ValueError: When input is empty, None, invalid format, or workspace root is not configured
        RuntimeError: When git repository is not found, git commands fail, or commit/PR not found
        FileNotFoundError: When git executable is not found in system PATH
        PermissionError: When access to the git repository is denied
    """
    from cursor.cursorAPI import fetch_pull_request
    return fetch_pull_request(pullNumberOrCommitHash=pr_number_or_commit_id)


def remember_codebase_fact(fact_to_remember, knowledge_entry_title, id_of_knowledge_to_update=None):
    """
    Makes a suggestion to the user to store a piece of learned knowledge
    (e.g., about deprecated functions, new patterns, facts about the codebase)
    into a persistent knowledge base for future reference by the AI.
    User must accept the tool call before the knowledge is stored.
    Especially important things to add to the knowledge base are operational
    knowledge about the codebase that are not obvious from just the code.
    As an example, using 'nvm use' before running terminal commands.
    If the user asks to remember something, for something to be saved,
    or to create a memory, you MUST use this tool. To update existing knowledge,
    provide the existing_knowledge_id parameter.

    Args:
        fact_to_remember (str): The specific piece of knowledge or fact to be stored.
                                  It should be no more than a paragraph in length (max 500 characters). 
                                  If the knowledge is an update or contradiction of previous
                                  knowledge, do not mention or refer to the previous
                                  knowledge.
        knowledge_entry_title (str): The title of the knowledge to be stored. This will be used to look
                     up and retrieve the knowledge later. This should be a short title
                     that captures the essence of the knowledge.
        id_of_knowledge_to_update (Optional[str]): Optional. The ID of existing knowledge
                                               to update instead of creating new
                                               knowledge. If provided, the
                                               knowledge_to_store and title will
                                               replace the existing knowledge entry.

    Returns:
        Dict[str, str]: A dictionary indicating the outcome of the operation.
        On success, contains:
            - 'message' (str): A confirmation message, which includes the ID
              of the created or updated knowledge.

    Raises:
        ValueError: If `fact_to_remember` is empty, if `knowledge_entry_title` is empty,
                    if `fact_to_remember` exceeds paragraph length,
                    or if an `id_of_knowledge_to_update` is provided but does not exist.
        InvalidInputError: If input parameters are of wrong type.
    """
    from cursor.cursorAPI import add_to_memory
    return add_to_memory(
        knowledge_to_store=fact_to_remember,
        title=knowledge_entry_title,
        existing_knowledge_id=id_of_knowledge_to_update
    )


def generate_mermaid_visualization(mermaid_dsl_string):
    """
    Creates a Mermaid diagram that will be rendered in the chat UI. Provide the raw Mermaid DSL string via `content`.
    Use <br/> for line breaks, always wrap diagram texts/tags in double quotes, do not use custom colors, do not use :::, and do not use beta features.
    The diagram will be pre-rendered to validate syntax - if there are any Mermaid syntax errors, a MermaidSyntaxError exception will be raised.

    Args:
        mermaid_dsl_string (str): Raw Mermaid diagram definition (e.g., 'graph TD; A-->B;').

    Returns:
        str: A confirmation message if the diagram is created successfully.
             Note: The diagram is also rendered and displayed in the chat UI.

    Raises:
        InvalidInputError: Raised when the mermaid_dsl_string is either not a string or is empty.
        MermaidSyntaxError: Raised when the Mermaid syntax is invalid.
        RuntimeError: Raised when diagram creation fails due to internal errors.
    """
    from cursor.cursorAPI import create_diagram
    return create_diagram(content=mermaid_dsl_string)


def autofix_linting_errors_from_edit(proceed_with_lint_fix):
    """
    Attempts to fix linting errors from the last edit by generating and applying new code edits.
    This function should be called if a previous edit introduced linting errors.

    Args:
        proceed_with_lint_fix (bool): A flag to execute the function. Must be True.

    Returns:
        Dict[str, Any]: A dictionary indicating the outcome. Contains:
            - 'message' (str): A message describing the outcome.
            - 'file_path' (str): The absolute, normalized path of the file processed.

    Raises:
        InvalidInputError: If `proceed_with_lint_fix` is False or if the last edit parameters are invalid.
        LastEditNotFoundError: If no previous edit information is found.
        FileNotInWorkspaceError: If the file from the last edit is not found.
        LintFixingError: If the lint fixing process fails.
        FailedToApplyLintFixesError: If the lint fixes are not applied successfully.
    """
    from cursor.cursorAPI import fix_lints
    return fix_lints(run=proceed_with_lint_fix)


def get_codebase_guidelines(guideline_names_to_fetch):
    """
    Fetches rules provided by the user to help with navigating the codebase.

    This function fetches rules provided by the user to help with navigating the codebase.
    Rules contain information about the codebase that can be used to help with generating code.
    If a user's request seems like it would benefit from a rule, this tool is used to fetch the rule.

    Args:
        guideline_names_to_fetch (List[str]): The names of the rules to fetch. Each string in the list
                                is the name of the rule to fetch.

    Returns:
        Dict[str, Any]: A dictionary containing the function's results.
            - 'rules' (Dict[str, Any]): A dictionary of fetched rules containing:
                - Keys (str): Rule names as specified in the input rule_names list
                - Values (Any): Rule content which can be strings, dictionaries, or other structured data

    Raises:
        ValidationError: If input arguments fail validation:
            - If guideline_names_to_fetch is not a list
            - If any element in guideline_names_to_fetch is not a string
            - If any rule name is empty or contains only whitespace
            - If any requested rule name is not found in available rules
    """
    from cursor.cursorAPI import fetch_rules
    return fetch_rules(rule_names=guideline_names_to_fetch)


def initiate_comprehensive_code_search(high_level_goal_description):
    """
    Ask a specialized search model to find relevant files, code blocks, and other context within the codebase.
    This tool is expensive since it requires waiting for a sub-agent to do a full search, so you should try to
    include all the relevant information in the query and avoid doing multiple searches about the same topic.

    Args:
        high_level_goal_description (str): The search query to ask the search model. The search model will receive NO other context
                    besides this. It should be a broad query that includes as much information as needed about
                    the user's high-level goal, so that the search model can provide a comprehensive answer
                    and you won't need to do additional searching.
                    Must be between 3 and 1000 characters long and contain at least one alphanumeric character.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries containing search results, each with:
            - 'file_path': Path to the file
            - 'snippet_bounds': Line numbers of the match
            - 'snippet_content': The matching code snippet
    Raises:
        InvalidInputError: If high_level_goal_description is empty, contains only whitespace, is shorter than 3 characters,
                          longer than 1000 characters, or contains only special characters.
        ValueError: If 'workspace_root' is not configured in DB.
    """
    from cursor.cursorAPI import deep_search
    return deep_search(query=high_level_goal_description)
