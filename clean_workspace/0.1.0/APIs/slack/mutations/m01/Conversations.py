# This file is automatically generated by the MutationBuilder

def exit_channel_or_group(departing_user_id, conversation_id_to_leave):
    """
    Leaves a conversation.

    Args:
        departing_user_id (str): User ID of the user leaving the conversation.
        conversation_id_to_leave (str): Conversation to leave.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): True if the operation was successful.

    Raises:
        TypeError: If 'departing_user_id' or 'conversation_id_to_leave' is not a string.
        ValueError: If 'departing_user_id' or 'conversation_id_to_leave' is an empty string.
        ChannelNotFoundError: If the specified 'conversation_id_to_leave' does not exist in the DB.
        UserNotInConversationError: If the 'departing_user_id' is not a member of the 'conversation_id_to_leave's' conversation.
    """
    from slack.Conversations import leave
    return leave(user_id=departing_user_id, channel=conversation_id_to_leave)


def add_users_to_channel(target_conversation_id, user_ids_to_invite_csv, ignore_invalid_users=False):
    """
    Invites users to a channel.

    Args:
        target_conversation_id (str): The ID of the channel to invite users to. Must be a non-empty string.
        user_ids_to_invite_csv (str): A comma separated list of user IDs. Must be a non-empty string.
        ignore_invalid_users (bool): Continue inviting valid users even if some are invalid. Defaults to False.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Whether the operation was successful
            - channel (str): Channel ID
            - invited (list): List of successfully invited user IDs
            - invalid_users (Optional[List[str]]): List of invalid user IDs if force is False and errors occur.

    Raises:
        TypeError: If 'target_conversation_id' or 'user_ids_to_invite_csv' is not a string or If 'ignore_invalid_users' is not a boolean.
        ValueError: If 'target_conversation_id' or 'user_ids_to_invite_csv' is an empty string.
        InvalidUserError: If any user is not present in the DB and ignore_invalid_users is false.
        ChannelNotFoundError: If the target_conversation_id does not exist in the DB.
    """
    from slack.Conversations import invite
    return invite(
        channel=target_conversation_id,
        users=user_ids_to_invite_csv,
        force=ignore_invalid_users
    )


def deactivate_and_close_channel(channel_identifier_to_archive):
    """
    Archives a conversation by setting its archived status and closing it.

    Archiving a conversation marks it as archived (is_archived=True) and closes it 
    (is_open=False) in the database. Archived conversations are typically hidden 
    from regular channel lists and are no longer actively used.

    Args:
        channel_identifier_to_archive (str): ID of conversation to archive. Must be a non-empty string.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Always True if the operation completes successfully.

    Raises:
        TypeError: If 'channel_identifier_to_archive' is not a string.
        ValueError: If 'channel_identifier_to_archive' is an empty string.
        ChannelNotFoundError: If the specified 'channel_identifier_to_archive' does not exist in the database.
        RuntimeError: If the internal database structure for the channel_identifier_to_archive is invalid 
                     (channel_identifier_to_archive data is not a dictionary).
    """
    from slack.Conversations import archive
    return archive(channel=channel_identifier_to_archive)


def enter_existing_channel(joining_user_id, channel_id_to_join):
    """
    Joins an existing conversation.

    Args:
        joining_user_id (str): User ID of the user joining the conversation.
        channel_id_to_join (str): ID of conversation to join.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Whether the operation was successful (False if user is already in channel)
            - channel (str): Channel ID

    Raises:
        TypeError: If 'joining_user_id' or 'channel_id_to_join' is not a string.
        MissingUserIDError: If 'joining_user_id' is an empty string.
        ChannelNameMissingError: If 'channel_id_to_join' is an empty string.
        ChannelNotFoundError: If the specified 'channel_id_to_join' does not exist in the DB.
    """
    from slack.Conversations import join
    return join(user_id=joining_user_id, channel=channel_id_to_join)


def eject_user_from_channel(source_conversation_id, user_to_be_removed_id):
    """
    Removes a user from a conversation.

    Args:
        source_conversation_id (str): ID of conversation to remove user from.
        user_to_be_removed_id (str): ID of user to remove from conversation.

    Returns:
        Dict[str, bool]: A dictionary containing:
            - ok (bool): Whether the operation was successful

    Raises:
        TypeError: If 'source_conversation_id' or 'user_to_be_removed_id' is not a string.
        ChannelNameMissingError: If 'source_conversation_id' is an empty string.
        MissingUserIDError: If 'user_to_be_removed_id' is an empty string.
        ChannelNotFoundError: If the specified 'source_conversation_id' does not exist in the DB.
        UserNotInConversationError: If the 'user_to_be_removed_id' is not a member of the 'source_conversation_id's' conversation.
        PermissionError: If the current user is not an admin or not in the source_conversation_id.
    """
    from slack.Conversations import kick
    return kick(channel=source_conversation_id, user_id=user_to_be_removed_id)


def update_channel_read_marker(conversation_to_mark_id, read_cursor_timestamp):
    """
    Sets the read cursor in a channel.

    Args:
        conversation_to_mark_id (str): Channel or conversation ID.
        read_cursor_timestamp (str): Timestamp of the message to mark as read.

    Returns:
        Dict[str, bool]: A dictionary containing:
            - ok (bool): Whether the operation was successful

    Raises:
        TypeError: If 'conversation_to_mark_id' or 'read_cursor_timestamp' is not a string.
        TimestampError: If 'read_cursor_timestamp' is an empty string or not in valid timestamp format. Required Format : Unix timestamp with fractional seconds (e.g. "1678886400.000000")
        MissingChannelError: If 'conversation_to_mark_id' is an empty string.
        ChannelNotFoundError: If the specified 'conversation_to_mark_id' does not exist in the DB.
    """
    from slack.Conversations import mark_read
    return mark_read(channel=conversation_to_mark_id, ts=read_cursor_timestamp)


def retrieve_channel_messages(
    conversation_id,
    pagination_marker=None,
    fetch_complete_metadata=False,
    include_boundary_messages=False,
    end_timestamp_filter=None,
    result_count_limit=100,
    start_timestamp_filter='0',
    filter_by_author_id=None
):
    """
    Fetches a conversation's history of messages and events.

    Args:
        conversation_id (str): Conversation ID. Must be a non-empty string.
        pagination_marker (Optional[str]): Pagination cursor. Defaults to None. If provided, must be a base64-encoded string
            with the format "user:{user_id}" (e.g., "dXNlcjpleGFtcGxlSWQxMjM=" for "user:exampleId123").
            This matches Slack's cursor format for consistent pagination.
        fetch_complete_metadata (bool): Return all metadata. Defaults to False. Must be a boolean.
        include_boundary_messages (bool): Include messages with oldest/latest timestamps.
            Defaults to False.
        end_timestamp_filter (Optional[str]): Only messages before this timestamp.
            Defaults to None (current time). If provided, must be a string in Unix timestamp format
            with exactly 6 decimal places for microsecond precision (e.g. "1688683055.556679").
            The timestamp must be a valid Unix timestamp that can be converted to a float.
        result_count_limit (int): Maximum number of items to return. Defaults to 100. Must be an integer between 1 and 999.
        start_timestamp_filter (str): Only messages after this timestamp. Defaults to "0". Must be a string in Unix timestamp format
            with exactly 6 decimal places for microsecond precision (e.g. "1688683055.556679").
            The timestamp must be a valid Unix timestamp that can be converted to a float.
        filter_by_author_id (Optional[str]): If provided, only messages whose ``user`` field matches this ID will be
            returned. Useful for filtering messages sent by a specific user.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Whether the operation was successful
            - messages (List[Dict[str, Any]]): List of message objects, where each message contains:
                - ts (str): Message timestamp in Unix format with exactly 6 decimal places for microsecond precision
                - user (str): User ID who sent the message
                - text (str): Message content
                - reactions (List[Dict[str, Any]]): List of reaction objects, where each reaction contains:
                    - name (str): Emoji name of the reaction
                    - users (List[str]): List of user IDs who reacted
                    - count (int): Number of users who reacted
            - has_more (bool): Whether there are more messages to fetch
            - response_metadata (Dict[str, Optional[str]]): Pagination metadata containing:
                - next_cursor (Optional[str]): Cursor for next page of results, in base64-encoded format
                    with the format "user:{user_id}" (e.g., "dXNlcjpleGFtcGxlSWQxMjM=")

    Raises:
        TypeError: If any argument is of an incorrect type.
        ValueError: If 'conversation_id' is an empty string.
        InvalidLimitError: If 'result_count_limit' is not an integer between 1 and 999 (include_boundary_messages).
        ChannelNotFoundError: If conversation_id is not found
        TimestampError: If `start_timestamp_filter` or `end_timestamp_filter` timestamps are invalid or not in the correct format
        InvalidCursorValueError: If 'pagination_marker' is provided but cannot be decoded properly.
    """
    from slack.Conversations import history
    return history(
        channel=conversation_id,
        cursor=pagination_marker,
        include_all_metadata=fetch_complete_metadata,
        inclusive=include_boundary_messages,
        latest=end_timestamp_filter,
        limit=result_count_limit,
        oldest=start_timestamp_filter,
        user_id=filter_by_author_id
    )


def start_or_resume_direct_message(
    resume_with_channel_id=None,
    disallow_creation=False,
    fetch_full_channel_object=False,
    participants_user_ids_csv=None
):
    """
    Opens or resumes a conversation between users.

    This function opens or resumes a conversation between users. When return_im=False (default), 
    the function returns minimal channel information containing only the channel ID. This is useful 
    when you just need to reference the channel without needing its full metadata. The function can 
    either resume an existing conversation by channel ID or create a new one with specified users.
    Note: Returns existing conversation if same user combination already exists.

    Args:
        resume_with_channel_id (Optional[str]): Resume a conversation by supplying a channel ID. 
            Defaults to None.
        disallow_creation (bool): Prevents creating a new conversation. 
            Defaults to False.
        fetch_full_channel_object (bool): If True, returns the full channel definition including all metadata. 
            If False, returns minimal channel information. Defaults to False.
        participants_user_ids_csv (Optional[str]): Comma-separated list of users. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Whether the operation was successful (always True for success)
            - channel (dict): Channel information. Content varies based on return_im parameter:
                - id (str): Channel ID
                - name (str): Channel name (comma-separated user list for conversations)
                - conversations (dict): Conversation metadata
                - messages (list): List of messages in conversation
                - is_private (bool): Whether conversation is private (True for user conversations)

    Raises:
        TypeError: If any parameter has incorrect type
        ValueError: If both resume_with_channel_id and participants_user_ids_csv are provided, or neither are provided, 
                   or resume_with_channel_id not found, or conversation not found when disallow_creation is True
    """
    from slack.Conversations import open_conversation
    return open_conversation(
        channel=resume_with_channel_id,
        prevent_creation=disallow_creation,
        return_im=fetch_full_channel_object,
        users=participants_user_ids_csv
    )


def enumerate_team_channels(
    channel_list_cursor=None,
    omit_archived_channels=False,
    result_set_limit=100,
    filter_by_team_id=None,
    channel_type_filter='public_channel'
):
    """
    Lists all channels in a Slack team.

    Args:
        channel_list_cursor (Optional[str]): Paginate through collections of data. Must be a string
            representing a non-negative integer if provided. Defaults to None.
        omit_archived_channels (bool): Set to true to exclude archived channels from the list.
            Defaults to False.
        result_set_limit (int): The maximum number of items to return. Must be between 1 and 1000.
            Defaults to 100.
        filter_by_team_id (Optional[str]): Encoded team id to list channels in. Defaults to None.
        channel_type_filter (str): Mix and match channel types by providing a comma-separated list of any
            combination of public_channel, private_channel, mpim, im.
            Defaults to "public_channel".

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Whether the operation was successful (always True if no exception is raised)
            - channels (list): List of channel objects
            - response_metadata (dict): Pagination metadata containing:
                - next_cursor (Optional[str]): Cursor for next page of results, or None if no more pages

    Raises:
        TypeError: If any argument has an invalid type (e.g., `result_set_limit` is not int,
            `omit_archived_channels` is not bool, `channel_list_cursor` is not str or None, `filter_by_team_id`
            is not str or None, `channel_type_filter` is not str).
        ValueError: If `result_set_limit` is outside the range [1, 1000].
        ValueError: If `channel_type_filter` contains invalid channel channel_type_filter or is improperly formatted.
        ValueError: If `channel_list_cursor` is provided but is not a string representing a non-negative integer.
        ValueError: If `channel_list_cursor` value exceeds the total number of available channels.
    """
    from slack.Conversations import list_channels
    return list_channels(
        cursor=channel_list_cursor,
        exclude_archived=omit_archived_channels,
        limit=result_set_limit,
        team_id=filter_by_team_id,
        types=channel_type_filter
    )


def hide_direct_message_conversation(direct_message_channel_id):
    """
    Closes a direct message or multi-person direct message.

    Args:
        direct_message_channel_id (str): Conversation to close.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Always True for successful operations

    Raises:
        TypeError: If direct_message_channel_id is not a string.
        ChannelNotFoundError: If the direct_message_channel_id parameter is empty or direct_message_channel_id doesn't exist.
        NotAllowedError: If the direct_message_channel_id is not a direct message or multi-person direct message.
    """
    from slack.Conversations import close
    return close(channel=direct_message_channel_id)


def change_channel_name(channel_id_to_rename, new_channel_name_value):
    """
    Renames a conversation.

    Args:
        channel_id_to_rename (str): ID of conversation to rename.
        new_channel_name_value (str): New name for conversation.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Always True for successful operations
            - channel (dict): Channel information containing:
                - id (str): Channel ID
                - name (str): New channel name

    Raises:
        TypeError: If channel_id_to_rename or new_channel_name_value is not a string.
        ChannelNotFoundError: If the channel_id_to_rename parameter is empty or channel_id_to_rename doesn't exist.
        ChannelNameMissingError: If the new_channel_name_value parameter is empty or None.
        ChannelNameTakenError: If a channel_id_to_rename with this new_channel_name_value already exists.
    """
    from slack.Conversations import rename
    return rename(channel=channel_id_to_rename, name=new_channel_name_value)


def fetch_channel_participants(
    target_channel_for_members,
    member_list_pagination_cursor=None,
    member_retrieval_limit=100
):
    """
    Retrieve members of a conversation.

    Args:
        target_channel_for_members (str): ID of the conversation.
        member_list_pagination_cursor (Optional[str]): Pagination cursor encoded in base64 in format "user:{user_id}". Defaults to None.
        member_retrieval_limit (int): Maximum number of items to return. Defaults to 100. Must be positive and cannot exceed 10000.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Whether the operation was successful
            - members (list[str]): List of member user IDs
            - response_metadata (dict): Pagination metadata containing:
                - next_cursor (str): Base64 encoded cursor for next page of results in format "user:{user_id}"

    Raises:
        TypeError: If 'target_channel_for_members' is not a string, 'member_list_pagination_cursor' (if provided) is not a string,
                   or 'member_retrieval_limit' is not an integer.
        ValueError: If 'target_channel_for_members' is an empty string, or 'member_retrieval_limit' is not a positive integer or if member_retrieval_limit > 10000.
        ChannelNotFoundError: If the specified 'target_channel_for_members' does not exist in the database.
        InvalidCursorValueError: If 'member_list_pagination_cursor' is provided but cannot be decoded properly.
    """
    from slack.Conversations import members
    return members(
        channel=target_channel_for_members,
        cursor=member_list_pagination_cursor,
        limit=member_retrieval_limit
    )


def establish_new_conversation_channel(new_channel_name, make_channel_private=False, associated_team_id=None):
    """
    Initiates a public or private channel-based conversation.

    Args:
        new_channel_name (str): Name of the channel. Must be a non-empty string.
        make_channel_private (bool): Create a private channel. Defaults to False. Must be a boolean.
        associated_team_id (Optional[str]): Encoded team id. Defaults to None. Must be a string if provided.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Whether the operation was successful (always True if no exception).
            - channel (dict): Channel information containing:
                - id (str): Channel ID
                - name (str): Channel name
                - is_private (bool): Whether channel is private
                - team_id (Optional[str]): Team ID
                - conversations (dict): Conversation settings containing:
                    - id (str): Conversation ID
                    - read_cursor (int): Read cursor position (initialized to 0)
                    - members (list): List of channel members (initially empty)
                    - topic (str): Channel topic (initially empty)
                    - purpose (str): Channel purpose (initially empty)
                - messages (list): Initial empty messages list

    Raises:
        TypeError: If 'new_channel_name' is not a string, 'make_channel_private' is not a boolean,
                   or 'associated_team_id' is not a string (if provided and not None).
        ChannelNameMissingError: If 'new_channel_name' is an empty string.
        ChannelNameTakenError: If the provided 'new_channel_name' is already in use by another channel.
    """
    from slack.Conversations import create_channel
    return create_channel(
        name=new_channel_name,
        is_private=make_channel_private,
        team_id=associated_team_id
    )


def define_channel_purpose(channel_identifier, channel_purpose_text):
    """
    Sets the channel description.

    Args:
        channel_identifier (str): Channel to set the description of.
        channel_purpose_text (str): The description of the channel.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Whether the operation was successful
            - purpose (str): The set purpose

    Raises:
        TypeError: If 'channel_identifier' or 'channel_purpose_text' is not a string.
        ChannelNameMissingError: If 'channel_identifier' is an empty string.
        MissingPurposeError: If 'channel_purpose_text' is an empty string.
        PermissionError: If the current user is not an admin.
        UserNotInConversationError: If the current user is not a member of the channel_identifier.
        ChannelNotFoundError: If the specified 'channel_identifier' does not exist in the DB.
    """
    from slack.Conversations import setPurpose
    return setPurpose(channel=channel_identifier, purpose=channel_purpose_text)


def update_channel_topic(target_conversation_identifier, new_topic_text):
    """
    Sets the topic for a conversation.

    Args:
        target_conversation_identifier (str): Conversation to set the topic of.
        new_topic_text (str): The new topic string.

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Whether the operation was successful
            - topic (str): The set topic

    Raises:
        TypeError: If 'target_conversation_identifier' or 'new_topic_text' is not a string.
        ChannelNameMissingError: If 'target_conversation_identifier' is an empty string.
        ValueError: If 'new_topic_text' is an empty string.
        ChannelNotFoundError: If the specified 'target_conversation_identifier' does not exist in the DB.
        UserNotInConversationError: If the current user is not a member of the target_conversation_identifier.
        PermissionError: If the current user is not an admin.
    """
    from slack.Conversations import setConversationTopic
    return setConversationTopic(channel=target_conversation_identifier, topic=new_topic_text)


def fetch_message_thread_replies(
    thread_channel_id,
    parent_message_timestamp,
    reply_pagination_cursor=None,
    include_all_reply_metadata=False,
    include_timestamp_boundaries=False,
    latest_reply_timestamp=None,
    reply_fetch_limit=1000,
    oldest_reply_timestamp='0'
):
    """
    Retrieve a thread of messages posted to a conversation.

    Args:
        thread_channel_id (str): Conversation ID.
        parent_message_timestamp (str): Timestamp of the parent message or a message in the thread.
        reply_pagination_cursor (Optional[str]): Pagination cursor. Defaults to None.
        include_all_reply_metadata (bool): Return all metadata. Defaults to False. Note: This parameter is currently not implemented and has no effect on the response.
        include_timestamp_boundaries (bool): Include messages with oldest/latest timestamps.
            Defaults to False.
        latest_reply_timestamp (Optional[str]): Only messages before this timestamp.
            Defaults to None.
        reply_fetch_limit (int): Maximum number of items to return. Defaults to 1000.
        oldest_reply_timestamp (str): Only messages after this timestamp. Defaults to "0".

    Returns:
        Dict[str, Any]: A dictionary containing:
            - ok (bool): Whether the operation was successful
            - messages (list): List of thread messages
            - has_more (bool): Whether there are more messages to fetch
            - response_metadata (dict): Pagination metadata containing:
                - next_cursor (str): Cursor for next page of results

    Raises:
        TypeError: If any argument is of an incorrect type.
        MessageNotFoundError: If there is no message found against the given parent_message_timestamp
        ChannelNotFoundError: If the given thread_channel_id name is not present
    """
    from slack.Conversations import replies
    return replies(
        channel=thread_channel_id,
        ts=parent_message_timestamp,
        cursor=reply_pagination_cursor,
        include_all_metadata=include_all_reply_metadata,
        inclusive=include_timestamp_boundaries,
        latest=latest_reply_timestamp,
        limit=reply_fetch_limit,
        oldest=oldest_reply_timestamp
    )
