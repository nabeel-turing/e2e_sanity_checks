# This file is automatically generated by the MutationBuilder

def get_directory_contents(folder_to_inspect, *, exclusion_patterns=None):
    """
    List the direct children of a workspace directory.

    Args:
        folder_to_inspect (str): Absolute directory path to list. Must reside inside the
            workspace root stored in SimulationEngine.db.DB.
        exclusion_patterns (Optional[List[str]]): Glob patterns to exclude from the
            listing, for example ['*.log', 'node_modules']. Defaults to None.

    Returns:
        List[Dict[str, Any]]: Each dictionary has these keys: name, path, is_directory, size, modifiedTime.

    Raises:
        InvalidInputError: If folder_to_inspect is empty, relative, or outside the workspace root.
        WorkspaceNotAvailableError: If workspace_root is not configured.
        FileNotFoundError: If folder_to_inspect does not exist in the DB.
        NotADirectoryError: If folder_to_inspect points to a file instead of a directory.
    """
    from gemini_cli.file_system_api import list_directory
    return list_directory(path=folder_to_inspect, ignore=exclusion_patterns)


def fetch_file_content(file_path_to_read, *, line_offset=None, max_lines_to_read=None):
    """
    Read content from a file in the simulated workspace.

    Reads and returns the content of a specified file from the local filesystem.
    Handles text, images (PNG, JPG, GIF, WEBP, SVG, BMP), and PDF files. For text 
    files, it can read specific line ranges with pagination support.

    Args:
        file_path_to_read (str): Absolute path of the file to read. Must be located under
            the configured workspace_root and not be ignored by .geminiignore patterns.
        line_offset (Optional[int]): For text files only, the 0-based line number to start 
            reading from. Requires 'limit' to be set. Use for paginating through large files.
        max_lines_to_read (Optional[int]): For text files only, maximum number of lines to read. 
            Use with 'offset' to paginate through large files. If omitted, reads up to 
            2000 lines by default. Also enforces a per-line length cap of 2000 characters.

    Returns:
        Dict[str, Any]: Object describing the retrieved content with the following structure:

        Required parameters (all file types):
            - size_bytes (int): Size of the file in bytes.

        # Optional parameters:
            - content (str): For text and SVG files, the plain text content. May include 
              truncation notices if the file was sliced due to offset/limit or line length limits.
            - inlineData (Dict[str, str]): For binary, image, audio, video and PDF files.
              Contains 'data' (base64-encoded payload) and 'mimeType' (detected MIME type 
              or 'application/octet-stream' as fallback).
            - encoding (str): Set to "base64" for binary files, included for backward compatibility.
            - start_line (int): For text files only, 1-based starting line number of the returned slice.
            - end_line (int): For text files only, 1-based ending line number (inclusive) of the 
              returned slice. Returns 0 when the file is empty.
            - total_lines (int): For text files only, total number of lines in the complete file.
            - is_truncated (bool): For text files only, True when the response was truncated 
              due to offset/limit values or per-line length limits.

    Raises:
        InvalidInputError: On type/format issues with parameters, relative paths, paths outside 
            workspace, or files ignored by .geminiignore patterns.
        WorkspaceNotAvailableError: If the workspace is not configured.
        FileNotFoundError: If the file_path_to_read does not exist.
        IsADirectoryError: If the file_path_to_read points to a directory, not a file.
        ValueError: If file size exceeds 20 MB max_lines_to_read.
        RuntimeError: If the DB entry is malformed.
    """
    from gemini_cli.file_system_api import read_file
    return read_file(path=file_path_to_read, offset=line_offset, limit=max_lines_to_read)


def update_or_create_file(destination_file_path, data_to_write, *, is_user_edit=None):
    """
    Write content to a specified file, creating parent directories if needed.

    This function writes the provided content to the specified file path. If the file
    already exists, it will be overwritten. If the file doesn't exist, it (and any
    necessary parent directories) will be created. The operation executes immediately
    without user approval or confirmation prompts.

    Args:
        destination_file_path (str): The absolute path to the file to write to. Must be within
            the workspace root.
        data_to_write (str): The content to write to the file. This will completely replace
            any existing content in the file.
        is_user_edit (Optional[bool]): Whether the proposed content was modified
            by the user. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing the operation result with keys:
            - success (bool): Whether the write operation succeeded
            - message (str): Success message describing the operation
            - file_path (str): The absolute path of the written file
            - is_new_file (bool): Whether this was a new file creation
            - size_bytes (int): The size of the written content in bytes
            - lines_count (int): The number of lines in the written content

    Raises:
        InvalidInputError: If destination_file_path is not a string, empty, not absolute, or
            outside the workspace root, or if data_to_write is not a string.
        WorkspaceNotAvailableError: If workspace_root is not configured.
    """
    from gemini_cli.file_system_api import write_file
    return write_file(
        file_path=destination_file_path,
        content=data_to_write,
        modified_by_user=is_user_edit
    )


def find_files_by_pattern(
    search_glob_pattern,
    *,
    search_directory=None,
    match_case=None,
    use_gitignore_rules=None
):
    """
    Find files matching a glob pattern, sorted by modification time (newest first).

    This function searches for files matching the specified glob pattern within the
    given directory (or workspace root if not specified). Results are sorted with
    recently modified files (within 24 hours) appearing first by modification time,
    followed by older files sorted alphabetically.

    Args:
        search_glob_pattern (str): The glob pattern to match files against. Supports wildcards
            like '*.py', '**/*.md', 'src/**/*.ts', etc.
        search_directory (Optional[str]): The absolute path to the directory to search within.
            If not provided, searches the workspace root. Must be within workspace.
        match_case (Optional[bool]): Whether the pattern matching should be
            case-sensitive. Defaults to False for case-insensitive matching.
        use_gitignore_rules (Optional[bool]): Whether to respect .gitignore patterns
            when finding files. Only applies if in a git repository. Defaults to True.

    Returns:
        List[str]: A list of absolute file paths matching the pattern, sorted by
            modification time (newest first for recent files, then alphabetically
            for older files).

    Raises:
        InvalidInputError: If search_glob_pattern is not a string, empty, or if search_directory is not
            absolute or outside the workspace root.
        WorkspaceNotAvailableError: If workspace_root is not configured.
        FileNotFoundError: If the specified search_directory does not exist.
        NotADirectoryError: If the specified search_directory is not a directory.
    """
    from gemini_cli.file_system_api import glob
    return glob(
        pattern=search_glob_pattern,
        path=search_directory,
        case_sensitive=match_case,
        respect_git_ignore=use_gitignore_rules
    )


def find_in_files_regex(regex_search_pattern, *, directory_to_search_in=None, file_inclusion_glob=None):
    """
    Search for a regular expression pattern within file contents.

    This function searches for the specified regex pattern within the content of files
    in the given directory (or workspace root if not specified). It uses a pure Python
    implementation to search through text files and returns matches with line numbers
    and content.

    Args:
        regex_search_pattern (str): The regular expression pattern to search for within file contents.
            Must be a valid regex pattern (e.g., 'function\s+myFunction', 'import\s+\{.*\}').
        directory_to_search_in (Optional[str]): The absolute path to the directory to search within.
            If not provided, searches the workspace root. Must be within workspace.
        file_inclusion_glob (Optional[str]): A glob pattern to filter which files are searched
            (e.g., '*.js', '*.{ts,tsx}', 'src/**'). If not provided, searches all files
            (respecting common ignore patterns).

    Returns:
        List[Dict[str, Any]]: A list of dictionaries containing match information.
            Each dictionary contains the following fields:
            - filePath: str - Relative path to the file
            - lineNumber: int - Line number (1-based)
            - line: str - The matching line content
            Results are sorted by file path, then by line number.

    Raises:
        InvalidInputError: If regex_search_pattern is not a valid regex, empty string, or if directory_to_search_in
            is not absolute or outside the workspace root.
        WorkspaceNotAvailableError: If workspace_root is not configured.
        FileNotFoundError: If the specified directory_to_search_in does not exist.
        NotADirectoryError: If the specified directory_to_search_in is not a directory.
    """
    from gemini_cli.file_system_api import grep_search
    return grep_search(
        pattern=regex_search_pattern,
        path=directory_to_search_in,
        include=file_inclusion_glob
    )


def perform_safe_replacement(
    file_to_modify,
    string_to_be_replaced,
    replacement_text,
    *,
    expected_occurrence_count=None,
    was_edited_by_user=None
):
    """
    Perform surgical string replacement with multi-stage self-correction.

    This function implements a sophisticated replacement workflow: checkpoint → diff → write.
    It performs exact string matching and replacement with intelligent error correction,
    validation of expected replacement counts, and comprehensive error handling.

    The function can create new files (when old_string is empty) or perform precise
    replacements in existing files. It includes multi-stage self-correction to handle
    common issues like string escaping problems or whitespace mismatches.

    Args:
        file_to_modify (str): Absolute path to the file to modify. Must be within workspace.
        string_to_be_replaced (str): Exact literal text to replace. Must include sufficient context
            (3+ lines before/after) for unique identification. Use empty string to create new file.
        replacement_text (str): Exact literal text to replace old_string with. Must be the
            complete replacement text with correct whitespace and formatting.
        expected_occurrence_count (Optional[int]): Number of replacements expected. Defaults to 1.
            Use when replacing multiple occurrences of the same string.
        was_edited_by_user (Optional[bool]): Whether the edit was modified manually by the user.
            Used for tracking user modifications. Defaults to None.

    Returns:
        Dict[str, Any]: Dictionary containing:
            - 'success' (bool): True if replacement completed successfully
            - 'message' (str): Human-readable result message
            - 'file_path' (str): Absolute path of the modified file
            - 'replacements_made' (int): Number of replacements actually performed
            - 'is_new_file' (bool): True if a new file was created
            - 'content_preview' (str): First 200 characters of new content for verification
            - 'modified_by_user' (bool): Whether the content was modified by user

    Raises:
        InvalidInputError: If parameters are invalid (non-string, empty file_to_modify, etc.)
        WorkspaceNotAvailableError: If workspace_root is not configured in DB
        ValueError: If file_to_modify is outside workspace boundaries
        FileNotFoundError: If trying to edit non-existent file (and string_to_be_replaced is not empty)
        IsADirectoryError: If file_to_modify points to a directory
        RuntimeError: If replacement count doesn't match expected_occurrence_count
    """
    from gemini_cli.file_system_api import replace
    return replace(
        file_path=file_to_modify,
        old_string=string_to_be_replaced,
        new_string=replacement_text,
        expected_replacements=expected_occurrence_count,
        modified_by_user=was_edited_by_user
    )
